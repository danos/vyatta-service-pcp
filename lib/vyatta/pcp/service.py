#!/usr/bin/python3
# Copyright (c) 2019 AT&T Intellectual Property.
# All Rights Reserved.
#
# SPDX-License-Identifier: GPL-2.0-only

import logging
import os
import subprocess

CONFIG_DIR = '/run/repcpd'
CONFIG_FILE = 'repcpd.conf'
PCP_SERVICE = 'repcpd'
PCP_APORT = 5350
PCP_SPORT = 5351

class PCPServer:
    def __init__(self, name, vrf, cfg):
        self.name = name
        self.vrf = vrf
        self.cfg = cfg
        self.prefix = []

    def complete(self):
        # no point running if no prefixes using it
        return len(self.prefix) > 0

    def generate(self, prog):
        # Generate config file content
        cfg_file = '# file generated by {} - do not edit\n'.format(prog)
        if self.complete():
            cfg = self.cfg
            if 'log' in cfg and 'debug' in cfg['log']:
                cfg_file += 'debug yes\n'
            cfg_file += 'lifetime 30-4294967295\n'
            try:
                nonce = cfg['nonce-check']
            except KeyError:
                nonce = yes
            cfg_file += 'nonce_check {}\n'.format(nonce)


            cfg_file += 'module_path /usr/lib/repcpd/modules\n'
            cfg_file += 'module syslog.so\n'
            cfg_file += 'module vyatta.so\n'

            cfg_file += self._generate_announce()
            cfg_file += self._generate_listen()
            cfg_file += self._generate_thirdparty()

            for prefix in self.prefix:
                cfg_file += prefix.generate()

        return cfg_file

    def _generate_announce(self):
        cfg = self.cfg
        cfg_file = ''
        try:
            acfg = cfg['announce']
        except KeyError:
            return cfg_file

        cfg_file += 'module announce.so\n'
        if 'multicast' in acfg:
            cfg_file += 'announce yes\n'

        try:
            ulist = acfg['unicast']
        except KeyError:
            return cfg_file

        for ucfg in ulist:
            try:
                addr = ucfg['address']
            except KeyError:
                continue
            try:
                port = ucfg['port']
            except KeyError:
                port = PCP_APORT
            cfg_file += 'announce_unicast [{}]:{}\n'.format(addr, port)

        return cfg_file

    def _generate_listen(self):
        cfg = self.cfg
        cfg_file = ''
        try:
            llist = cfg['listener']
        except KeyError:
            cfg_file += 'udp_listen [0.0.0.0]:{}\n'.format(PCP_SPORT)
            cfg_file += 'udp_listen [::]:{}\n'.format(PCP_SPORT)
            return cfg_file

        for lcfg in llist:
            try:
                addr = lcfg['address']
            except KeyError:
                continue

            try:
                port = lcfg['port']
            except KeyError:
                port = PCP_SPORT

            cfg_file += 'udp_listen [{}]:{}\n'.format(addr, port)

        return cfg_file

    def _generate_thirdparty(self):
        cfg = self.cfg
        cfg_file = ''
        try:
            tpcfg = cfg['third-party']
        except KeyError:
            cfg_file += 'client yes\n'
            return cfg_file

        cfg_file += 'thirdparty yes\n'

        try:
            ilist = tpcfg['interface']
        except KeyError:
            return cfg_file

        for icfg in ilist:
            try:
                iname = icfg['name']
            except KeyError:
                continue
            cfg_file += 'thirdparty_interface {}\n'.format(iname)

        return cfg_file


class PCPTemplate:
    def __init__(self, name, server, cfg):
        self.name = name
        self.server = server
        self.cfg = cfg

    def generate(self):
        # Generate config file content for template
        cfg = self.cfg
        cfg_file = ''
        if 'opcodes' in cfg:
            if 'announce' in cfg['opcodes']:
                cfg_file += ',announce'
            if 'map' in cfg['opcodes']:
                cfg_file += ',map'
        return cfg_file


class PCPPrefix:
    def __init__(self, pname, iname, template):
        self.name = pname
        self.iname = iname
        self.template = template

    def generate(self):
        # Generate config file content for prefix
        cfg_file = 'prefix {},{}'.format(self.name, self.iname)
        if self.template:
            cfg_file += self.template.generate()
        cfg_file += '\n'
        return cfg_file


class PCPService:
    def __init__(self, prog, vrf):
        self.prog = prog
        self.vrf = vrf
        self.cfg = {}
        self.log = logging.getLogger()
        if vrf == 'default':
            self.cfg_dir = CONFIG_DIR
            self.service = PCP_SERVICE
        else:
            self.cfg_dir = '{}/vrf/{}'.format(CONFIG_DIR, vrf)
            self.service = '{}@{}'.format(PCP_SERVICE, vrf)

    def get_cfg(self):
        return self.cfg

    def configure(self, cfg):
        self.cfg = cfg
        self.log.debug('configure {}: {}'.format(self.vrf, cfg))
        self.server = {}
        self.template = {}
        self.prefix = []

        # Create servers and templates.
        # There will only be one each of these at present, enforced in the yang.
        self._servers(cfg)

        # Create prefixes.
        # There may be multiple of these.
        # At present, all will refer to same template (or none).
        self._prefixes(cfg)

        # Make sure config directory exists
        try:
            os.makedirs(self.cfg_dir, exist_ok=True)
        except Exception as e:
            self.log.error(e)
            return

        # Write config file(s)
        # At present there is only one.
        # We might need one per server and per template later.
        start_stop = 'stop'
        for _, server in self.server.items():
            if server.complete():
                start_stop = 'restart'
            cfg_file = server.generate(self.prog)
            file = '{}/{}'.format(self.cfg_dir, CONFIG_FILE)
            self.log.debug('writing config file {}'.format(file))
            try:
                with open(file, 'w') as f:
                    f.write(cfg_file)
            except Exception as e:
                self.log.error(e)
                return

        # Start or stop the service.
        # No need to run if template is not bound to any interfaces.
        self._systemctl(start_stop, self.service)

    def shutdown(self):
        # Stop the service.
        self._systemctl('stop', self.service)

    def _prefixes(self, cfg):
        # Create prefixes. There may be multiple of these.
        # At present, all will refer to same template (or none).
        try:
            ilist = cfg['feature-interface']
        except KeyError:
            self.log.debug('{}: feature-interface list not found'.format(self.vrf))
            return
        for icfg in ilist:
            try:
                iname = icfg['name']
            except KeyError:
                self.log.debug('{}: interface name not found'.format(self.vrf))
                continue

            try:
                tlist = icfg['template']
            except KeyError:
                self.log.debug('{}: template list not found'.format(iname))
                continue

            for tcfg in tlist:
                try:
                    tname = tcfg['name']
                except KeyError:
                    self.log.debug('{}: template name not found'.format(iname))
                    continue
                try:
                    template = self.template[tname]
                except KeyError:
                    self.log.debug('{}: template not found'.format(tname))
                    continue

                try:
                    plist = tcfg['internal-prefix']
                except KeyError:
                    self.log.debug('{}-{}: internal-prefix list not found'.format(iname, tname))
                    continue

                for pcfg in plist:
                    try:
                        pname = pcfg['prefix']
                    except KeyError:
                        self.log.debug('{}-{}: prefix name not found'.format(iname, tname))
                        continue
                    pfx = PCPPrefix(pname, iname, template)
                    template.server.prefix.append(pfx)
                    self.log.debug('prefix {}: interface {} template {}'.format(pname, iname, tname))

                # only one template allowed at present
                return

    def _servers(self, cfg):
        # Create servers.
        # There will only be one of these at present, enforced in the yang.
        try:
            slist = cfg['server']
        except KeyError:
            self.log.debug('{}: no servers found'.format(self.vrf))
            return

        for scfg in slist:
            try:
                name = scfg['name']
            except KeyError:
                self.log.debug('{}: no server name found'.format(self.vrf))
                continue
            server = PCPServer(name, self.vrf, scfg)
            self._templates(server, scfg)
            self.server[name] = server

    def _templates(self, server, cfg):
        # Create templates for server.
        # There will only be one of these at present, enforced in the yang.
        try:
            tlist = cfg['template']
        except KeyError:
            self.log.debug('{}: no templates found'.format(server.name))
            return

        for tcfg in tlist:
            try:
                name = tcfg['name']
            except KeyError:
                self.log.debug('{}: no template name found'.format(server.name))
                continue
            self.template[name] = PCPTemplate(name, server, tcfg)

    def _systemctl(self, start_stop, service):
        # Start or stop the service.
        self.log.info('{} {}'.format(start_stop, service))
        systemctl = ['systemctl', start_stop, service]
        try:
            subprocess.run(systemctl)
        except Exception as e:
            self.log.error(e)
